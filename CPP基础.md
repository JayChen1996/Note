[toc]

# 类型

## 引用

1. 本质是已经存在对象的一个别名，它本身不是对象，
2. 定义时必须初始化
3. 不能为空，所以使用前不用检测是否为空
4. 无法重新绑定另一个对象
5. 只能指向一个对象而不能指向常量

sdf

## 指针

1. 本身是一个对象，存储的事指向对象的地址
2. 可以不在定义时初始化，
3. 可以为空，使用前必须测试其合法性
4. 允许复制和拷贝，允许更改指向的对象



### void指针

1. 可以指向任意类型的数据
2. malloc返回类型为void*



### 函数指针

1. 函数类型的指针，指向具体函数

2. 函数类型：由返回类型及形参类型共同决定，与函数名无关

3. 函数形参为函数类型时会被编译器自动转换成该函数类型的指针




## 类型转换

### C风格类型转换

````c++
T b = (T)a;
````

- 没有类型检查，存在安全隐患



### C++类型转换

#### static_cast

1. 没有类型检查，存在安全隐患：运行时错误
2. C++隐式转换使用static_cast实现
3. 用途
   - 基础类型之间的转换
   - void指针与其他指针间的转换
   - 继承关系中上行转换：派生类指针（引用）转换为基类指针（引用）



#### dynamic_cast

1. 有运行时类型检查，转换失败返回空指针或抛出异常（引用间转换）
2. 基于虚函数进行转换，判断被转换对象与目标类型的虚函数表是否一样
3. 用途
   - 虚继承关系中的下行转换：基类指针（引用）转换为派生类指针（引用）



#### const_cast

1. 对指针及引用进行常量，将常量指针（引用）转换为非常量指针（引用）
2. 注意：对常量使用const_cast去常量后修改原常量值，可能引发未定义行为



#### reinterpret_cast

1. 重新解释，用于处理无关类型转换
2. 使用reinterpret_cast会让代码难以移植
3. 用途：
   - 不同指针类型、足够大的整数及枚举之间的转换



# 声明

## const

### 概念

常量声明，被其声明的值不允许修改： 

1. 修饰普通变量：值不允许修改
2. 修饰指针变量：
   - const在*左边，修饰\*ptr整体，指针指向的值不允许修改
   - const在*右边，修饰ptr本身，指针本身值不允许修改，即不可指向其他变量
3. 修饰成员函数：放在成员函数参数列表后面
   - 实际是修饰成员函数隐式的this指针指向的对象，不允许该成员函数修改对象成员变量
   - 可使用mutable可变声明修饰某成员变量，使其可被const成员函数修改
4. 用途：
   - 限制某个值不允许修改
   - 函数使用const引用传参可以避免临时变量的复制，节省资源
   - 修饰非内置类型的函数返回值，使其不能作为左值使用



### 与define的区别

1. 处理方式
   - define在预编译阶段展开，替换使用处的内容
   - const在编译阶段使用
2. 类型安全检查
   - define没有类型，不做类型检查
   - const有具体类型，编译阶段执行类型检查
3. 存储方式
   - define在预编译阶段进行展开替换，不做分配内存，不做储存
   - const声明的变量会分配内存
4. 效率
   - define定义的宏每次展开替换都是一个拷贝
   - const声明的变量在内存中唯一，只有一份拷贝，效率更高
5. 调试：
   - define定义的宏在预编译阶段就进行展开替换了，在执行时没有，所以不能调试
   - 一些集成化调试工具能够对const常量进行调试，



## static

静态声明，被其声明的变量储存在全局数据区。

1. 静态局部变量
   - 储存：全局数据区
   - 内存分配：执行到变量定义处时分配内存并初始化，且只分配这一次；
   - 释放：程序运行结束时释放
2. 静态全局变量
   - 储存：全局数据区
   - 内存分配：程序开始运行时分配内存并初始化，且只分配这一次；
   - 释放：程序运行结束时释放
   - <font color ="orangered">**只在声明它的文件可见，其他文件存储的只是其拷贝（修改独立）**</font>。
3. 静态成员变量
   - 储存：全局数据区
   - 初始化：程序开始运行时分配内存并初始化，且只分配这一次；
   - 释放：程序运行结束时释放
   - 特点：
     - 类中只声明，在类外定义，且必须定义，否则将导致链接出错
     - 不依赖于实例，被类的所有对象共享，不是实例的一部分，因此sizeof不会计算它
4. 静态成员函数
   - 不依赖于实例，被类的所有对象共享
   - 能够在类中和类外进行定义
   - 不能访问类的非静态成员，但可以被非静态成员访问
   - 由于没有this指针的额外开销，比非静态成员函数效率稍高



## volatile

1. 易变声明，告诉编译器被其声明的变量可能会被意想不到的改变，因此需要每次从内存中去读取这个值，防止因编译器优化而从缓存中读取，如寄存器
2. 常用于多线程应用
3. const声明限制程序不能修改该变量，但还是可能被其他程序修改，所以const与volatile不冲突



## extern

1. 全局声明，被其声明的变量或函数可以在本编译单元或其他编译单元中使用
2. 在其声明文件及引用其声明文件的所有文件里只能出现一次定义，若声明与定义在一个文件，多次引用该文件会造成重定义错误
3. 声明与定义必须分开
4. 与static冲突
5. extern "C"：告诉编译器在编译时按C的规则翻译函数名



## friend

1. 友元声明，在类中声明函数或类，使其可以访问声明所在类的私有和保护成员
2. 友元不是类的成员
3. 声明：
   - 友元声明放在public、protected或private效果一样
   - 友元声明只是指定访问权限，而不是一般意义上的函数声明，
   - 类成员函数声明为其他类的友元时，需要在其他类之前声明，并在其他类定义后再定义。
   - 非成员函数及类的声明不是必须在友元声明之前，但除了友元声明，在使用前必须声明一次（即使该该函数定义在类内）



### 友元函数

1. 不是任何类的成员
2. 由于不是声明类的成员，没有this指针，因此访问非静态成员时需要声明类的对象做参数
3. 对于全局的声明类对象或访问其静态成员，则不需要对象做参数



### 友元类

1. 该类的所有成员均为原始类的友元
2. 友元关系是单向的，且不能被传递和继承



## inline

1. 内联声明，放在函数体前，编译器在编译时会将被其声明的函数在使用处展开，而不是运行时调用

2. 内联函数体小的函数，可以规避函数调用时的入栈出栈等操作，节省时间，提高效率

3. 内联声明是对编译器的一种请求，是否执行内联由编译器判断，因此内联声明可能被拒绝
   - 内联大函数将会导致调用处代码臃肿，因此内联大函数会被编译器拒绝
   - 虚函数在编译时不知道具体函数，因此内联虚函数将被拒绝
   - 递归函数在编译时不知道调用次数，无法展开且代码很多，因此内联递归函数将被拒绝
   
4. 定义在类内部的成员函数是自动内联的

5. 推荐使用内联函数取代宏函数，避免边际效应

6. 最好将内联函数定义在头文件中：

   - 内联函数可以在程序中多次定义，但其多个定义必须完全一致
   - 这是因为编译器想要展开函数仅有函数声明是不够的，还需要函数定义
   - 将内联函数定义在头文件中，调用该内联函数只需引用该头文件即可顺利展开

   



# 类

## 类类型

### class与struct

1. struct的默认访问权限、默认继承权限均为 public
2. class的默认访问权限、默认继承权限均为 private



### 声明与定义

1. 类在声明后定义前，是一种不完全类型，只能定义该类型的指针，以及声明以其作为返回值类型的函数。
2. 类只有在定义后数据成员才能被声明为这种类类型，因此，类的数据成员不能是自己，但可以是自身类型的指针。



### 缺省成员函数

一个空类默认提供6个缺省成员函数：

1. 缺省构造函数
2. 缺省拷贝构造函数
3. 缺省析构函数
4. 缺省赋值运算符
5. 缺省取址运算符
6. 缺省const取址运算符



## 构造与析构

### 构造函数

#### 概念

1. 定义类对象的初始化方式，用于初始化类对象的数据成员
2. 构造函数通过初始值列表初始化数据成员，若数据成员没在初始值列表中进行初始化，则会在构造函数体之前执行默认初始化
   - 函数体内执行数据成员的初始化操作本质上是对数据成员进行赋值，而不是真的初始化
   - const数据成员若没有默认值则必须在初始化列表中初始化
   - static数据成员不依赖于具体对象，所以不依赖于构造函数，其必须在类外定义
   - 数组成员不能在初始化列表中初始化



#### 特点

1. 不能被声明为const：
   - 构造函数初始化完成，对象才被创建，此时对象才有const属性一说，
   - 因此构造函数能够在const对象的构造过程中修改其数据成员
2. 名字与类名相同，没有返回类型
3. 允许重载



#### 默认构造函数

1. 若没有显示定义任何构造函数，编译器会隐式定义一个默认构造函数
   - 若存在类内初始值，则用它来初始化成员，否则默认初始化该成员
   - 有时无法生成默认构造函数：如含有某个类类型成员且其没有默认构造函数
2. 在参数列表后加上`=default`需要默认行为，要求编译器生成默认构造函数
   - 出现在类内部时，默认构造函数是内联的，否则不是内联的



#### 构造流程

1. 分配内存
2. 基类构造函数
   - 初始化基类数据成员：若数据成员为类类型，则执行数据成员的构造函数
3. 派生类构造函数
   - 初始化派生类数据成员：若数据成员为类类型，则执行数据成员的构造函数



#### 注意

1. 派生类构造函数中的某些初始化可能依赖于基类初始化。
2. 若没有显式调用基类构造函数，则会调用基类默认构造函数，若基类没有默认构造函数，则会报错



#### explicit

显式构造声明，用于声明构造函数，表示该构造函数不支持隐式构造。



### 析构函数

#### 析构流程

1. 派生类析构函数
   - 释放派生类数据成员：若数据成员为类类型，则先执行数据成员的析构函数
2. 基类析构函数
   - 释放基类数据成员：若数据成员为类类型，则先执行数据成员的析构函数
3. 释放内存



##  this指针

### 概念

1. 指向当前对象的常量指针，其指向的内容默认为非常量



### 机制

1. 在类对象的内存空间中，只有数据成员及虚指针，成员函数则存放与代码段中，
2. 成员对象通过this指针知道调用的具体对象，访问对象的数据成员及虚函数
3. this指针实质是成员函数的一个隐式形参，在编译时被编译器添加到成员函数的参数列表中
4. 调用成员函数时，对象地址被用来初始化this，传入成员函数，在成员函数执行结束后清除



### 特点

1. 只能在非静态成员函数中使用
2. this指针指向的内容默认为非常量的，因此不能绑定到一个常量对象上，这导致了不能使用一个常量对象调用普通成员函数，
3. 常量对象可以调用常量成员函数，因为常量成员函数实际上是将this声明为了指向常量内容的常量指针
4. 不同编译器中this指针的存放位置不同，大多数编译器使用寄存器传递this指针



### 用途

1. 返回对象本身：*this
2. 参数名与成员变量名字相同时，用于区分两者：`this.name = name;`



### delete this

1. 在析构函数中调用：导致栈溢出。delete本身会调用析构函数，形成无限递归。

2. 成员函数中调用：极易造成指针错误

   - 只要涉及数据成员及虚函数的操作均会出现无法预料的错误

   - 其他操作能够正常运行：可以用于编写类似release功能的函数



## 重载、重写和隐藏

1. 重载：函数名相同，参数列表不同，无关返回类型
2. 重写：覆盖
   - 派生类中对基类函数重新定义，函数名、参数列表及返回类型均相同
   - 只有虚函数才能被重写，在基类中必须被声明为virtual
   - 基类指针指向派生类对象，用基类指针调用该函数时，将会调用派生类的函数，
3. 隐藏：
   - 派生类存在与基类同名的非虚函数时，基类函数将被隐藏，无关参数列表及返回类型
   - 基类指针指向派生类对象，用基类指针调用该函数时，将会调用基类的函数



## 函数对象

### 概念

1. 一切具有函数行为的对象都可以称为函数对象，所谓的函数行为是指的是可以使用`()`调用并传递参数：

   - 重载了函数调用符`()`的类的实例就是一种函数对象，而`lambda`表达式是其中特殊的一种函数对象

2. STL算法可以接收`lambda`表达式，也可以接收普通函数对象和函数指针，这是因为STL算法是泛型实现的，只要支持函数调用符就能接受

3. 相较于普通函数，函数对象具有以下优势：

   - **函数对象带有状态**：

     - 函数对象除了提供函数调用符方法，还可以拥有其他方法和数据成员。即使同一个类实例化的不同的函数对象其状态也不相同。
     - 而且函数对象是可以在运行时创建。

   - **函数对象有自己的类型**：

     - 对于普通函数来说，只要签名一致，其类型就是相同的。
     - 而函数对象的类型是其类的类型，这意味着函数对象可以用于模板参数，这对泛型编程有很大提升。

   - **函数对象一般快于普通函数**：

     - 因为函数对象一般用于模板参数，模板一般会在编译时会做一些优化。

     函数对象用于计算均值：

     ```cpp
     class MeanValue
     {
     public:
         MeanValue(): num{0}, sum{0} {}
     
         void operator()(int e)
         {
             ++num;
             sum += num;
         }
     
         double value() 
         { 
             return static_cast<double>(sum) / static_cast<double>(num); 
         }
     private:
         int num;
         int sum;
     };
     
     int main()
     {
         vector<int> v{ 1, 3, 5, 7 };
         MeanValue mv = std::for_each(v.begin(), v.end(), MeanValue{});
         cout << mv.value() << endl;  // output: 2.5
     
         return 0;
     }
     ```

     

# 多态

## 模板

### 概念

1. <font color ='orangered'>**模板是创建类或函数的蓝图或公式**</font>，依照模版参数创建具体版本的类或者函数

2. 模板参数列表不能为空，以逗号分隔
   - 类型参数：表示类或函数定义中用到的类型，用typename或class来指定
   - 非类型参数：表示类或函数定义中用到的==**常量值**==，用一个特定的类型名来指定

3. 使用模板时需要隐式或显示的指定模板实参，将其绑定到模板参数上

4. 实例化：当编译到定义时不生成代码，<font color ='orangered'>**当编译器编译到模板的调用处时，根据模板实参生成具体版本的类或函数**</font>

5. **==函数模板和类模板成员函数的定义通常放在头文件中==**：模板在调用时实例化，需要生成代码，因此需要掌握模板的定义，否则会产生 "未定义引用" 错误

6. 由于模板在使用时才会被实例化，**==多个独立编译的源文件可能会分别实例化相同的模板，造成额外的开销==**。
   - 可通过显式实例化来避免：对具体的模板实例使用extern声明，同时在所有文件中有且仅有一个该类型的显式实例化定义。



### 函数模板

1. 模板函数实例化的函数可以看作是函数的重载

2. 函数模板可以声明为inline或constexpr

3. 编译器可以根据函数参数列表推断模板参数类型，相当于隐式指定模板实参

4. 特化：针对需要进行特殊处理的类型，对其进行单独的实现

5. ==**可以作为类的成员函数，但此时该成员函数不能是虚函数**==：
   - 编译器在编译类的时候要为类生成虚函数表，而在此时还不知道函数模板会实例化多少个函数，除非扫描所有代码。



### 类模板

1. 需要显式指定模板实参

2. ==**成员函数只有当程序用到它时才进行实例化**==，使得即使某种类型不能完全符合模板操作的要求，仍然能够使用该类型实例化类。

3. 友元：

   - 若友元为非模板类或函数，则友元应用于所有模板实例
   - 若友元为模板类或函数，则友元为一对一关系
   - 若将模板类型参数声明为友元，则与当前模板实例具有相同模板类型的目标是其友元。

    

## 虚函数

### 概念

1. 主要作用：**运行时多态**，父类指针指向子类对象，通过该指针调用的实际函数是在运行时被确定的。

2. 实现：**虚函数指针 + 虚函数表**

3. **必须被实现**：如果不实现就使用，编译器将报错：undefined reference to "XXX"。
   - 父类中提供虚函数的实现，为子类提供默认的函数实现。
   - 子类可以重写父类的虚函数实现子类的特殊化。

4. **==有继承关系时，父类的析构函数必须设置成虚函数==**：
   - 若父类析构函数不是虚函数，则只会释放父类对象的资源：

```cpp
BaseClass* pObj = new SubClass(); 
delete pObj;  
```



### 虚函数表

1. **虚函数的地址按声明顺序保存在虚函数表中**
2. **一个类的虚函数表中依次为父类、自身虚函数地址**
3. **若子类重写了父类虚函数，那么在子类中对应该父类虚函数地址的项被替换成子类虚函数地址**
4. **==虚函数表与类相关，与对象无关，类的所有对象共有一个虚函数表==**
5. 若子类继承了多个拥有虚函数表的父类，则其会拥有多个虚函数表。
6. 多继承中，子类的虚函数地址放第一个虚函数表中。（按继承的声明顺序）
7. 在多继承中，若多个父类拥有同名虚函数，而子类重写了该虚函数，则子类的所有虚函数表中的同名虚函数地址都将会被替换。
8. 内存模型：

```cpp
Base1: f(), g(), h();
Base2: f(), g(), h();
Base3: f(), g(), h();

Derive: f(), g1(), h1();             //重写f()

|Derive::f()|Base1::g()|Base1::h()|Derive::g1()|Derive::h1()|.|
|Derive::f()|Base2::g()|Base2::h()|.|
|Derive::f()|Base3::g()|Base3::h()|.|
//Derive 继承Base1, base2, base3
//Derive拥有三张虚函数表：
//重写f()后，所有表中的f()都被覆盖
```



### 虚函数指针

1. **拥有虚函数表的类的对象，其对象空间的首地址存储一个虚函数指针，指向该类的虚函数表的首地址**

2. **==虚函数指针与类对象相关，储存在类对象首地址==**

3. 其他：

   - 通过父类指针访问子类自己的虚函数会编译出错。
   - **可以使用访问虚函数表的方式来访问non-public的虚函数**

   ```cpp
   class Base {
       private:
               virtual void f() { cout << "Base::f" << endl; } 
   };
   class Derive : public Base{};
   typedef void(*Fun)(void);  // 函数指针
   
   void main() {
       Derive d;
       int** pVtab = (int**)&d;// 虚函数表 函数指针数组
       pFun = (Fun)pVtab[0][0]; //第一个虚函数表的第一个虚函数
       pFun();
   }
   ```

   

### 纯虚函数

1. **基类中不定义，但要求任何派生类都要定义自己的实现方法****：用来规范派生类的行为。

2. 包含纯虚函数的类，被称为**抽象类**

3. **抽象类不能实例化，只有实现了这个纯虚函数的子类才能创建对象**

   ```cpp
   virtual void funtion1()=0;  //在基类中实现纯虚函数的方法是在函数原型后加“=0”
   ```

   

### 虚继承

1. **菱形继承**：

   - 类D继承自类B1、B2，类B1、B2都继承自类A，那么在类D中将会两次出现类A中的变量和函数。
   - 如果D中要访问A中的变量或函数，就需要显示地加以限定，使用B1::param或者B2::param,以消除歧义性，否则会造成在D中访问A中数据时出现路径不明确的编译错误。

2. **虚继承：在任何派生类中的虚基类总用同一个（共享）对象表示**

   - 上述例子中，为了节省内存空间，可以将B1、B2对A的继承定义为**虚拟继承**，而A就成了**虚拟基类**，使得A的变量和函数在D中只出现一次

   ```cpp
   class A 
   class B1:public virtual A; 
   class B2:public virtual A; 
   class D:public B1,public B2;
   ```

   

3. **使用虚继承与不使用的区别：**
   - **时间**：在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。
   - **空间：**由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承节省空间。虚拟继承可以防止出现**菱形继承**时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证 这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。



## RTTI（待整理）



# 内存

## 内存溢出与内存泄漏

1. 内存溢出：程序在申请内存时，没有足够的内存空间供其使用
   - 内存加载的数据过于庞大
   - 递归太深导致栈溢出
   - 内存泄漏导致的溢出

2. 内存泄漏：程序没有释放已经使用完的内存空间
   - new申请的内存没有用delete释放



## new 与 delete

### 特点

1. 用于**动态内存管理**的一对**运算符（关键字）**
2. new用于在堆区创建对象，使用结束时必须用delete显式释放对象，否则会造成内存泄漏
3. 通过operator new和operator delete进行内存的申请和释放
   - 这两者是C++标准库函数，不是new与delete运算符的重载，new与delete不允许重载



### 底层机制

**new**

1. 调用operator new函数分配内存，并返回其起始地址
   - new [] 非内置类型会在空间头部多申请4个字节用于储存数组长度
2. 在分配的内存上，对对象初进行始化，
   - 若为内置类型则直接初始化，否则调用其构造函数
   - new [] 会执行多次初始化
3. 返回对象指针
   -  new []返回第一个对象地址，若为非内置类型则是分配的空间首地址后移4个字节位置

**delete**

1. 若为非内置类型，首先调用析构函数销毁对象
   - delete [] 会从对象指针前面4个字节取出数组长度，调用多次析构函数
2. 调用operator delete 释放内存



### 注意

1. new[] 与 delete[] 必须配对使用，
   - 对于非内置类型，只使用delete只能销毁释放第一个对象，造成内存泄漏
   - 对于内置类型，因为底层直接调用operator delete释放内存，只使用delete没有影响，但不推荐
2. 使用delete释放一个非new分配的内存或多次释放相同指针，其行为是未定义的
3. delete一个指针过后，指针仍保存该地址，但内容无效，指针变成<font color="orangered">**悬空指针**</font>，通过将其置为nullptr可防止意外使用。



### 缺点

1. new 申请的内存若没有使用delete释放，会造成内存泄露；
2. 释放还有其他指针指向的并使用内存，会产生引用非法内存的指针（悬空指针）；
3. 使用new与delete直接管理内存的类与使用智能指针的类不同，不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。



###  与malloc/free的区别

1. malloc/free是C/C++的标准库函数，而new/delete是操作符（关键字）
2. malloc只分配内存，不进行初始化；free只释放内存，不销毁对象



## 浅拷贝与深拷贝

### 浅拷贝：

1. 本质是 "**位拷贝**" 或值拷贝：
   - 对于基本类型及指针类型的数据成员，按**字节**进行拷贝
   - 对于类类型的数据成员，调用其对应的构造函数
2. 对于指针类型的成员，只负责指针本身的值，而不拷贝指针指向的内存，存在以下缺陷：
   - 拷贝时，当前对象的指针成员原本指向的内存空间没有释放，造成<font color="orangered">**内存泄漏**</font>
   - 当前对象与拷贝对象的指针指向同一块内存，修改会相互影响
   - 一个对象析构释放，会导致另一个对象的指针成员指向被释放的内存，产生<font color="orangered">**悬空指针**</font>问题
3. 若类没有定义拷贝构造函数，在对象拷贝时系统会提供一个缺省的拷贝构造函数，默认使用浅拷贝。



### 深拷贝

1. 对于指针成员，深拷贝会开辟一个新的内存，并将指针指向内存的值复制到新开辟的空间
2. 不存在悬空指针问题



## 内存对齐(待整理)

## 左值与右值

### 概念

1. **左值**：==**占据内存中某个可识别位置（地址）的对象，可取址，可赋值**==，可理解为持久存在
2. **右值**：非左即右，可理解为临时存在

3. **左值引用**：一般意义上的引用就是**左值引用**，它是对左值的引用，写作X&，修改左值引用就相当于修改左值引用引用的那个左值本身的内容。
4. **右值引用**：对右值的引用，写作X&&。**==用于支持转移语义==**：
   - 转移语义可以将资源从一个对象转移到另一个对象，减少临时对象的创建、拷贝以及销毁，提高 程序性能。
   - 如转移构造函数与转移赋值符：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。

```cpp
 int&& x = 3; // 3是右值，x是右值3的右值引用，其本身是左值，可以赋值和取址
```



### move()函数

1. **==只有右值能够进行转移，左值不能隐式的转换成右值==**（杜绝危险的隐式转移，防止左值被转移后再次被使用，导致的危险境况）
2. **==std::move：用于将左值转换为右值，让其可以转移==**：用于某些左值不再被使用的情况下，将其转移，可节省资源
3. **==如果使用了mova()函数转化某个左值并进行转移后，还继续使用它，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误==**

```cpp
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a); 				// 错误，因为a是左值，unique_ptr只有转移构造函数，没有拷贝构造函数，不能接受左值作为参数
unique_ptr<Shape> c(make_triangle());   // 正确，make_triangle()返回的对象是临时对象，是一个右值，能够被转移

unique_ptr<Shape> d(std::move(a));   // 正确，a被转换为右值，转移后，a将不能被使用
```



## 内存分区（待完善）

1. 栈
   - 由编译器分配，效率高，内存空间有限，
   - 形参和局部变量分配在栈区，
   - 向低地址生长的一块连续的内存
2. 堆
   - 由程序员控制内存的分配和释放的存储区，可能造成二次删除和内存泄漏
   - new关键字定义的变量存储在堆中
   - 向高地址生长的不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，（new 程序运⾏行行时分配的）
3. 静态/全局存储区
   - 存储全局变量和静态变量，以及**字符串常量**
   - 初始化的变量放在初始化区，未初始化的变量放在未初始化区
   - 在程序结束后释放这块空间
4. 常量存储区
   - 存储常量，只能读不能写
5. 代码区（自由存储区）
   - 存放二进制代码
   - 可读不可写



## 内存模型（待整理）



## RAII（待整理）



# 编译原理（待完善）

## 编译链接过程

1. **预编译**：**去除注释、展开宏定义，处理理预编译指令**   ->  生成 .i 文件 

2. **编译**：对 .i 文件进行**词法、语法、语义分析**  ->  生成 .s **汇编代码**文件

3. **汇编**：**将汇编代码翻译成目标机器指令**  ->  生成 .obj **目标文件**（包括**代码段、数据段**）

4. **链接**：**将工程中所有的obj文件进行链接**  ->  生成最终的 .out 或 .exe 文件。



## 静态链接和动态连接

1. **静态链接**：**将汇编生成的 .obj 目标文件与引用到的库==一起链接打包==到可执行文件**

   - **库更新更麻烦**：静态库更新需要将使用它的程序重新编译发布

2. **动态链接**：**动态库在程序==运行时载入==**

   - **规避了空间浪费问题**：不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例
   - **库更新更简单**：动态库更新后只需替代程序中的动态库文件即可，无需重新编译发布整个程序

3. 全局变量处理方式

   - 当前应用全局变量与静态库全局变量重名：编译出错，提示多次定义错误；因为静态被链接成当前程序的一部分
   - 当前应用全局变量与动态库全局变量重名：编译不会出错，当前应用全局变量覆盖动态库全局变量
   - 静态库与动态库、或多个动态库全局变量或函数重名：先链接优先，只会记录先链接的动态库变量吗名或函数，之后的被忽略
   - 多个静态库全局变量重名：重定义错误

4. **多进程引用动态库全局变量：使用copy-on-write机制**

   - 动态库被加载进内存时，进程可以直接读取动态库的全局变量
   - 当进程修改该全局变量时，会将其进行拷贝，发生修改的是拷贝后的独立副本，因此多进程对动态库全局变量的修改相互独立，互不影响

5. 使用方式

   - 动态链接

     - 运行时加载（显式运行时链接）：使程序在运行时控制加载的指定的模块，在不需要使用的时候卸载；API：dlopen(), dlsym(), dlclose(), dlerror()
     - 隐式调用：环境变量，或增加编译器调用路径

   - 静态链接：编译时使用命令

     

### 常见错误

1. **编译错误：主要为语法错误**

   - 非法字符（中文字符等）
   - 用抽象类创建实例
   - 没引用头文件
   - 对指针使用.而不是->访问成员
   - **忘加分号**

2. **链接错误：主要为重复定义错误等**

   - 变量或函数可以多次声明，但只能定义一次，否则会产生重复定义错误

   - 函数声明时，并为分配实际物理空间，有时可保证编译通过
   - 函数定义时，在内存中就有了实际的物理空间；若变量或函数只有声明没有定义，即使编译通过，链接时也会出错



# C++ 11新特性

## 类型推导

### auto

1. 类型推导
2. 相当于类型占位符，编译器在编译时会根据其初始化表达式将其替换为实际类型

### 优点

1. 简化代码
2. 避免类型声明错误

### 注意

1. 声明的变量必须被初始化
2. 不能用于函数传参：声明函数时并不知道之后会传进的参数类型，因此不能推导
3. 数组类型会被推导成相应类型的指针：因为数组变量被看作指向其第一个元素的指针
4. auto声明的同一序列的变量必须是同一类型：`auto i = 5, j = 6, k = 7; `
5. auto推断时忽略顶层const、volatile等；
   - 当auto被声明为引用类型时，也并未推断const等，只是原值本身就含有const、volatile

### 底层机制（待整理）



### decltype

1. 获取表达式类型，而不像用表达式的值初始化变量（与auto不同）
2. 不计算表达式的值，只分析类型
3. 能够推断出const、volatile声明
4. 能够推断出引用
5. 对于解引操作，auto推断出原有类型，而decltype推断出引用
6. 作用于函数时返回的是函数类型而非函数指针



## 智能指针

### 特点

1. 智能指针是一种行为类似指针的类模板，用于更容易、更安全的管理动态内存；
2. 能够自动销毁所指向的对象并释放该内存，避免直接new与delete产生内存泄漏或野指针；



### auto_ptr

1. C++98提供的智能指针，已废弃，它有如下问题：
   - 用一个auto_ptr构造另一个auto_ptr会置空原智能指针，相当于对左值进行移动构造，此时使用原auto_ptr相当于使用空指针，非常危险。



### unique_ptr

1. 独占指向的对象：同一时刻只能有一个unique_ptr指向给定对象

2. 构造方式：支持移动构造，不支持拷贝构造

   - 不能通过一个unique_ptr构造另一个unique_ptr，除非前者被显示通过move()函数转换为右值
   - 函数返回unique_ptr时，原unique_ptr是局部对象，将要被销毁，编译器判断其为右值，所以能进行拷贝返回

3. 析构：

   - unique_ptr释放时，所指向的对象将被销毁释放；reset也可释放原对象
   - 管理非new创建的对象或没有析构函数的对象时，应该传入删除器

4. 常见函数：

   - release：返回管理对象的普通指针，并将unique_ptr置空，切断了与原对象的联系，其返回的指针可用于构造另一unique_ptr（不释放原对象内存）
   - reset：使unique_ptr指向另一个对象，若unique_ptr不为空则释放原对象

   

### shared_ptr

1. 计数机制：储存该智能指针的引用次数

   - 超出作用域析构或使用reset()时引用次数减1，拷贝时引用次数加1
   - 每次计数减少都判断是否为0，当计数为0时销毁指向的对象并释放内存

2. 构造方式：

   - 其构造函数为explicit构造函数，不支持普通指针转换为智能指针，只能直接构造
   - 可通过直接构造、拷贝构造、unique_ptr构造、weak_ptr构造及make_shared生成
   - ==make_shared==：最安全的shared_ptr构造方式，在堆中分配内存后马上初始化对象，避免普通构造时，普通指针创建到构造shared_ptr之间发生异常引发的问题

3. 释放方式：

   - 默认使用delete进行释放
   - 若管理非new创建的或没有析构函数的对象，则需要传入相应的删除器

4. 注意：

   - 避免使用同一普通指针初始化不同的shared_ptr：它们的引用次数相互独立不共享
   - 避免普通指针与智能指针混用：智能指针过期自动释放，普通指针变成悬空指针
   - 循环引用：两个shared_ptr管理的对象相互持有对方的shared_ptr，导致引用永不为0，不能释放。可以通过weak_ptr解决

5. 常见函数：

   - use_count：获取引用计数
   - make_shared：构造
   - reset：重置当前智能指针，引用次数减一；可以将智能指针指向其他对象
   - get：获取管理对象的普通指针
   - 其他：指针操作符->、*，构造析构函数，赋值操作符=，

6. 场景：

   - 拷贝时进行浅拷贝，共享相同内存的成员变量的类，销毁时不能销毁其所有成员变量
   - 管理C与C++共同使用的库，传入删除器进行一些特殊操作：如网络库中连接的自动断开

   

#### 引用计数如何确保线程安全（待整理）



### weak_ptr

1. 本身不具有指针行为，指向shared_ptr管理的对象，用于解决shared_ptr的循环引用问题
   - 通过将循环引用问题中的一个shared_ptr替换成week_ptr解决
2. 与shared_ptr配合使用：
   - 通过shared_ptr构造时不增加引用计数
   - 使用lock()函数时，检查对象是否仍存在，若是，则生成shared_ptr，shared_ptr的引用计数加1



## lambda表达式

### 特性

1. 形式：

   ```cpp
   [捕捉列表](参数列表) mutable(可选) constexpr(c++17可选) exception(可选) attribute(可选) -> ret { body };
   ```

   - `[]`：捕捉列表，
     - `[]`：为空默认不捕获任何变量
     - `[=]`：以传值方式捕获所有变量
     - `[&]`：以引用方式捕获所有变量
     - `[x]`：以传值方式捕获变量x，其它变量不捕获；
     - `[&x]`：以引用方式捕获变量x，其它变量不捕获；
     - `[=, &x]`：以传值方式捕获所有变量，但是x是例外，通过引用方式捕获；
     - `[&, x]`：以引用方式捕获所有变量，但是x是例外，通过传值方式捕获；
     - `[this]`：以引用方式捕获当前对象（其实是复制指针）；
     - `[*this]`：以传值方式捕获当前对象；
   - `()`：参数列表
   - `mutable`：可选，将`lambda`表达式标记为`mutable`后，函数体就可以修改传值方式捕获的变量；
   - `constexpr`：可选，C++17，可以指定`lambda`表达式是一个常量函数；
   - `exception`：可选，指定`lambda`表达式可以抛出的异常；
   - `attribute`：可选，指定`lambda`表达式的特性；
   - `ret`：可选，返回值类型；拖尾返回类型
   - `body`：函数执行体。

2. 赋值：

   - `lambda`表达式间无法相互赋值，因为`lambda`表达式禁用了赋值操作符

   ```cpp
   auto a = [] { cout << "A" << endl; };
   auto b = [] { cout << "B" << endl; };
   
   a = b;   // 非法，lambda无法赋值
   auto c = a;   // 合法，生成一个副本
   ```

   ```cpp
   ClosureType& operator=(const ClosureType&) = delete; //lambda表达式禁用了赋值操作符
   ```

   - `lambda`表达式没有禁用复制构造函数，因此可以使用`lambda`表达式初始化另一个`lambda`表达式从而产生副本；

   - `lambda`表达式也可赋值给相应的函数指针，因此可以将其看作对应类型的函数指针



### 原理

1. 对每个`lambda`表达式，**==编译器会自动生成一个匿名类，这个类重载了函数调用运算符`()`==**，称为闭包类型，此时类的对象具有类似函数的行为，称为函数对象或仿函数。
2. 在运行时，`lambda`表达式会返回一个匿名的闭包实例，即函数对象，其本身是一个右值。
3. 变量捕捉：
   - 闭包可以通过传值或者引用的方式捕捉其封装作用域内的变量，`lambda`表达式前方的方括号`[]`就是用来定义捕捉模式以及变量，称为`lambda`捕捉块
   - 捕捉方式：
     - 传值捕捉：匿名类中会添加对应类型的非静态数据成员，在运行时，使用捕捉的值初始化这些成员变量，从而生成闭包。
       - 传值捕捉的`lambda`表达式，其匿名对象函数调用符 `()`的重载方法是const属性的，不可修改捕捉的变量；
       - 通过使用`mutable`标记`lambda`表达式，可以将函数调用符 `()`的重载方法设为非const属性，这样即可修改传值捕捉的变量
     - 引用捕捉：引用捕捉的变量在闭包类中是否有对应类型的数据成员，C++标准中并未规定，与编译器相关
       - 无论是否标记`mutable`，都可修改捕捉的值



### 安全性

1. **最好不要使用`[=]`和`[&]`默认捕获所有变量：可能引发==悬挂引用==问题**

   - 以引用方式捕获时：

     ```cpp
     std::function<int(int)> add_x(int x)
     {
         return [&](int a) { return x + a; };
     }
     ```

     参数`x`仅是一个临时变量，函数调用后就被销毁，但是返回的`lambda`表达式却引用了该变量，但调用这个表达式时，引用的是一个垃圾值，所以会产生没有意义的结果。

   - 以传值方式引用时，上述例子可以避免悬挂引用问题，但在某些情况下仍有风险：

     ```cpp
     class Filter
     {
     public:
         Filter(int divisorVal): divisor{divisorVal} {}
     
         std::function<bool(int)> getFilter() 
         {
             return [=](int value) {return value % divisor == 0; };
         }
     
     private:
         int divisor;
     };
     ```

     由于数据成员`divisor`对`lambda`表达式并不可见，而每个非静态成员函数都有一个`this`指针，上述代码通过捕获this指针来访问`divisor`，其等同于：

     ```cpp
     std::function<bool(int)> getFilter() 
     {
         return [this](int value) {return value % this->divisor == 0; };
     }
     ```

     尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以`lambda`表达式的闭包与一个类对象绑定在一起了，这也很危险，因为你仍然有可能在类对象析构后使用这个`lambda`表达式，那么类似“悬挂引用”的问题也会产生。

     所以，**==采用默认值捕捉所有变量仍然是不安全的，主要是由于指针变量的复制，实际上还是相当于按引用传值==**




### C++14 lambda表达式

1. **泛型`lambda`表达式**：

   - 通过使用将参数类型定义为`auto`，即可让编译器通过类型推导自动判断参数类型，从而实现泛型，其推导规则与函数模板相同

   ```cpp
   auto add = [](auto x, auto y) { return x + y; };
   
   int x = add(2, 3);   // 5
   double y = add(2.5, 3.5);  // 6.0
   ```

   

2. **`lambda`捕捉表达式**：用表达式初始化捕捉变量，与使用`auto`声明一个变量的机理是类似的。

   - 更灵活的处理捕捉的变量

     ```cpp
     int x = 4;
     auto y = [&r = x, a = x + 1] { r += 2; return a * a; }();// 此时 x 更新为6，y 为25
     
     auto z = [str = "string"]{ return str; }(); // 直接用字面值初始化变量
     ```

   - 允许捕捉不在其作用域范围内的变量

   - 允许捕捉右值 ：使用`std:move()`，这对不能复制只能移动的对象很重要，比如`std::unique_ptr`，因为其不支持复制操作，无法以值方式捕捉到它

     ```cpp
     auto myPi = std::make_unique<double>(3.1415);
     
     auto circle_area = [pi = std::move(myPi)](double r) { return *pi * r * r; };
     cout << circle_area(1.0) << endl; // 3.1415
     ```

     

# STL

## 容器

### vector

1. 底层数据：数组

2. 当容量不足时会自动进行扩容：

   - 分配当前容量两倍大小的新空间
   - 将vector里的所有旧数据依次复制到新空间
   - 析构就空间的所有对象，并释放空间
   - 若元素为指针类型，将指针值复制到新空间，不会析构指针指向的对象，只释放原指针

3. 空间回收：

   - 删除或clear清空数据时，容量不会变
   - shrink_to_fit：收缩capacity来适应size大小
   - 通过与临时空vector进行swap交换数据，可析构释放原本空间

4. 越界访问：不会被编译器发现，运行时会产生缓冲区溢出错误（buffer-overflow）

   - 某些编译器下，访问size外capacity内的数据为默认初始化数据，而capacity外的数据为未知数据

5. 避免不必要的动态扩容：通过reserve或resize设置初始空间大小

   - reserve：设置容器容量capacity，不进行对象初始化，size不变，不能访问未初始化元素
   - resize：设置容器大小size，并进行对象初始化，可访问已初始化的元素

6. 扩容极限容量：max_size

7. 时间复杂度：

   - 访问指定位置元素：O(1)
   - 查找、插入、删除：O(N)

   

### list

1. 底层数据结构：双向链表
2. 离散储存，
3. 无固定空间大小，动态分配储存空间，不会像vector那样造成空间浪费
4. 不支持随机访问
5. 单个元素较vector占用更多的空间：因为有指针域
6. 时间复杂度：
   - 访问指定元素、查找：O(n)
   - 插入、删除：O(1)



### stack

1. 底层数据结构：栈
2. 先进后出
3. 没有迭代器



### queue

1. 底层数据结构：队列
2. 先进先出
3. 没有迭代器



### priority_queue

1. 底层数据结构：用数组实现的容器，如vector、deque等，默认vector
2. 本质为堆，优先度大的元素在队头
3. 时间复杂度：
   - 取出、添加：O(logN)



### deque

1. 底层数据结构：分块连续空间，可动态增加新一段空间链接起来，无容量概念
2. 底层实现：通过一块连续空间map（非数据结构map）作主控，存储每个deque块的指针，将它们链接起来，维护其整体连续的假象
3. 当map满载，需要再找一块更大的空间作map，将指针数据复制到新map，释放旧空间
4. 双端队列：可在头尾两端进行插入和删除，头部操作效率很低
5. 支持随机访问及迭代器，通过map块进行支持



### set / multiset

1. 底层数据结构：[红黑树](./数据结构与算法.md#红黑树（RB树）)
2. 有序集合，根据键值排序
3. 键：本身的值充当键，set不允许键值重复，multiset允许键值重复
4. 元素修改：不能直接修改元素，只有删除旧元素再插入新元素，否则会打乱原有排序
5. 迭代器：其迭代器为const_iterator，不能通过迭代器改变元素的值，因为其值就是键，关系到元素的排序，双向迭代器
6. 时间复杂度：
   - 插入、删除、查找：O(logN)



### unordered_set

1. 底层数据结构：[Hash表](数据结构与算法.md#Hash表)
2. 时间复杂度：平均时间复杂度接近常量时间O(1)，最坏O(N)：冲突太多导致冲突或插入太多数据导致rehash
3. 单向迭代器



### map / multimap

1. 底层数据结构：[红黑树](./数据结构与算法.md#红黑树（RB树）)
2. 储存元素为pair类型键值对，map键不能重复，multimap键值能重复
3. map支持下标存取，multimap不支持
4. 有序储存：根据键值排序
5. 不允许通过迭代器更改元素键值，会影响排序性
6. 空间占用率高：每个节点需要保存父节点、孩子节点指针及颜色



 map<int,string> 删除key能被2整除的元素（代码，其实主要是erase导致迭代器失效的问题），

### unordered_map

1. 底层数据结构：[Hash表](数据结构与算法.md#Hash表)
2. 时间复杂度：平均时间复杂度接近常量时间O(1)，最坏O(N)：冲突太多导致冲突或插入太多数据导致rehash
3. 单向迭代器



## 算法（待整理）



## 迭代器（待整理）



## 仿函数（待整理）



## 适配器（待整理）



## 空间配置器（待整理）



# 源码实现

#### memcpy

- 源地址src与目标地址dst有重合时，源地址值将会被覆盖
- 若目标地址dst在源地址src右边，且有重合时，为防止src在拷贝前被覆盖，应从后往前拷贝

```cpp
void * memcpy(void* dst, const void* src, size_t n)
{
    if(dst == nullptr || src == nullptr) return nullptr;
    char* psrc = (char*)src;
    char* pdst = (char*)dst;
    
    //dst在src右边且两者有重合
    if( psrc < pdst && psrc + n > pdst )
        while(n--)  *(pdst + n) = *(psrc + n);  
    else
        while(n--) *(pdst++)=*(psrc++);
    return dst;
}
```



### 多线程（待整理）



# 代码附录