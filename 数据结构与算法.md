[toc]

# 数据结构

## 线性表

- 元素按线性方式排列

### 顺序表

- 存储空间连续，支持随机访问
- O(1)读取，O(n)查找、插入、删除，适用于多随机访问场景

#### 类别

1. 数组：容量固定
2. 动态数组：容量动态变化



### 链表

- 存储空间离散，地址通过指针连接，不支持随机访问
- 由于含有指针域，空间效率不如顺序表
- O(1)插入、删除，O(n)查找、读取，适用于频繁插入删除的场景

#### 类别

1. 单链表：每个节点一个指针，只能单向遍历
2. 双链表：每个节点两个指针，支持双向遍历
3. 循环链表：头尾相连，可分为单向循环链表和双向循环链表



## 扩展线性表

### 栈

- 后进先出（Last In First Out，LIFO）特性的线性表
- 栈顶进行入栈出栈操作



### 队列

- 先进先出（First In First Out，FIFO）特性的线性表
- 队头出队，队尾入队

#### 类别

1. 顺序队列
2. 循环队列



### 堆

- 优先队列，优先级高的先出队
- 堆顶取出，堆底插入
- 物理上使用线性表从上至下从左至右存储堆元素，逻辑结构可以看成二叉树

#### 类别

1. 大顶堆：堆顶数据最大，每个节点大于其两个子节点
2. 小顶堆：堆顶数据最小，每个节点小于其子节点

#### 创建

1. 从最后一个非叶子节点开始，进行shiftdown操作，直到根节点

2. shiftdown：若节点N优先度低于**最优先子节点**，则交换两者位置，继续比较N

#### 插入

1. 在堆底插入新元素，并对其进行上滤（percolate up）操作
2. 上滤：若节点N优先度大于其父节点，则交换两者位置，继续比较N

#### 取出

1. 在堆顶进行取出操作，然后对其进行下滤（percolate down）操作
2. 下滤：将该节点较大子节点N置于原本父节点位置，继续对原本N的子节点进行比较



## Hash表

- 通过hash函数 H(key) 直接计算得到键值对应数据的储存位置
- 查找、插入、删除时间复杂度接近 O(1)
- 在hash表空间被基本填满时，性能下降非常严重，需要进行重散列
- 重散列：将原hash表键值对放到新的大小合适的hash表中，并根据新大小重新计算hash值



### 常见hash函数

1. 线性散列：

   H(key) = a * key + b

2. 取余散列

   H(key) = key % a

3. 平方散列

   H(key) = (key * key) >> 28

4. 斐波那契散列（将乘数换成斐波那契数列的一项，取决于操作系统位数）

   H(key) = (key * 2654435769) >> 28



### hash冲突

若通过hash函数得到的hash值相同，称为hash冲突，而同一个地址不可能存多个数，所以需要对冲突进行解决：

1. **开放定址法**

   - 冲突时根据探测序列d~i~去找下一个空的哈希地址 ：h~i~ =  ( H(key) + d~i~ ) % m
     - 其中，H(key) 为哈希函数，m为表大小，d~i~为探测序列
   - 容易发生冲突聚集

   根据探测序列取值方式不同，可分为以下三种：

   1. 线性探测：d~i~ = i，（i = 1，2，3，...，n），容易聚集
   2. 二次探测：d~i~ = +- i^2^，即1，-1，4，-4，...，（i = 1，2，3，...，n），较不容易聚集
   3. 伪随机探测：d~i~ = 伪随机数列，较前两种不容易聚集

2. **再哈希法**

   - 通过多个不同的hash函数，一个冲突时，用下一个去计算

   - 虽然不容易发生冲突聚集，但增加了计算时间

3. **拉链法（链地址法）**

   - 通过指针将相同hash值的元素连成一个单链表，hash表节点存链表头指针
   - 适用于插入和删除较多的情况

4. **建立公共溢出区**

   - 将哈希表分为基础表和溢出表两部分，冲突元素填入溢出表



## 树

- 元素非线性存储
- 子节点：一个节点具有零个或多个子节点，通过指针储存子节点地址；
- 父节点：非根节点只有一个父节点，根节点无父节点
- 度：节点的度为其子节点数，树的度为所有节点度的最大值
- 深度：树的深度为树的层数，有时会定义成根节点到叶节点的最长距离



### 二叉树

- 每个节点最对两个子节点，即度最大为2
- 子树有左右之分，次序不能颠倒，即使某一子树为空也要区分左右子树
- 第i层最多2^(i-1)^个节点

#### 常见类别

1. 完全二叉树：

   - 所有叶节点的高度相差不超过1
   - 只有最下面两层节点度小于2，且最下面一层节点集中在左边

2. 满二叉树：

   - 所有叶节点在同一层，除最后一层，每层节点都有两个子节点
   - 深度为h时，具有2^h^-1个节点的二叉树

3. 二叉查找树 BST：

   - 每个节点大于左子节点值，小于右子节点值
   - 查找、插入、删除操作的时间依赖于树的具体拓扑结构，时间复杂度为O(logN)~O(N)

4. 平衡二叉查找树：简称平衡二叉树

   - 每个左右子树高度相差不超过 1 的二叉查找树
   - 平衡因子（Balance Factor，BF）：节点左子树与右子树的高度(深度)差，H(左)-H(右)
   - 出现原因：二叉查找树操作时间复杂度不稳定，其退化成线性表时操作复杂度O(N)
   - 查找、插入、删除时间复杂度都为O(logN)

5. 自平衡二叉查找树：

   - 每次插入、删除都需要额外的操作使树恢复平衡

   - AVL树：最早的自平衡二叉查找树
   - 红黑树

#### 遍历

二叉树的遍历有三种方式，分别为：

1. 前序遍历：当前节点->左子树->右子树
2. 中序遍历：左子树->当前节点->右子树
3. 后序遍历：左子树->右子树->当前节点



### 平衡二叉树（AVL树）

#### 失衡调整

- 若节点平衡因子绝对值超过1，则其为失衡节点，需要进行失衡调整，使子树重新平衡
- 通过旋转来实现：分为左旋和右旋，把高度小的子树往下旋转，左小->左旋，右小>右旋

#### 左旋

- 左子树低，实行左旋

**流程：**

1. 节点的右孩子代替节点位置
2. 有孩子的左子树编程节点的右子树
3. 节点本身编程有孩子的左子树

#### 右旋

- 右子树低，实行右旋

**流程：**

1. 节点左孩子代替节点位置
2. 左孩子的右子树编程节点的左子树
3. 节点本身变成左孩子的右子树

#### 修正规则

1. LL：BF(A) > 1 && BF(lchild) > 0，节点左子树高，且节点左孩子的左子树高
   - 对A执行一次右旋即可
2. RR：BF(A) < -1 && BF(rchild) < 0，节点右子树高，且节点右孩子的右子树高
   - 对A执行一次左旋即可
3. LR：BF(A) > 1 && BF(lchild) < 0，节点左子树高，且节点左孩子的右子树高
   - 对A的左孩子执行一次左旋
   - 再对A执行一次右旋
4. RL：BF(A) < -1 && BF(rchild) > 0，节点右子树高，且节点右孩子的左子树高
   - 对A的右孩子执行一次右旋操作
   - 再对A执行一次左旋操作

#### 插入

对于节点A，有四种插入方式导致A左右子树高度差大于1：

1. 在A的左孩子的左子树插入（LL）
   - 对A执行一次右旋即可
2. 在A的右孩子的右子树插入（RR）
   - 对A执行一次左旋即可
3. 在A的左孩子的右子树插入（LR）
   - 对A的左孩子执行一次左旋
   - 再对A执行一次右旋
4. 在A的右孩子的左子树插入（RL）
   - 对A的右孩子执行一次右旋操作
   - 再对A执行一次左旋操作

**流程**：

1. 查找插入位置，路径上节点入栈，直到找到插入位置
2. 插入元素，更新高度
3. 节点依次出栈并判断其BF，若BF绝对值大于1，判断失衡类型并进行相应修正
4. 出栈直到栈空（其实修正一个节点后就可退出，因为插入只需修正==第一个非平衡节点==）

#### 删除

1. 查找删除元素A，路径上节点入栈，直到找到删除的元素

2. 删除元素A：

   - 若A右子树存在，则将A值设为右子树中最小（左）的那个叶节点的值，删除该叶节点

   - 若A右子树不存在，则令左孩子代替A位置，并释放A（无右子树则左孩子为叶节点）

3. 节点依次出栈并判断其BF，若BF绝对值大于1，判断失衡类型并进行相应修正

4. 出栈直到栈空（删除需要对路径上==所有非平衡节点==依次修正）

#### 时间复杂度

- 查找：O(logN)
- 修改：O(logN) = 查找O(logN) + 更改O(1)
- 插入：O(logN) = 查找O(logN) + 插入节点O(1) + 旋转O(1)
- 删除：O(logN) = 查找O(logN) + 删除节点O(1) + 旋转O(1) ~ O(logN)



### 红黑树（RB树）

- ==非严格平衡==的自平衡二叉查找树

#### 规则

1. 节点非黑即红
2. 根节点必为黑
3. 叶节点都为黑，且为NULL
4. 红节点的两个子节点都为黑（不会出现相邻红节点）
5. 从任意节点出发，到其每个叶节点的路径中包含相同数量的和节点
   - ==保证没有一条路径长度超过其他路径两倍==

#### 插入

1. 查找插入位置
2. 以红色节点插入元素（可能违背规则4）
3. 判断是否需要变色旋转使其重新变成红黑树

可分为三种情况：

1. 插入的是根节点：直接将节点设为黑色即可
2. 插入节点的父节点是黑色：无需任何操作，插入后任然是红黑树
3. 插入节点的父节点是红色：思路为==将红色的节点移到根节点；然后，将根节点设为黑色==
   - 根据叔叔节点（可能为空）的情况，可以分为一下三类：
     - 叔叔节点为红色：
       1. 将父节点和叔叔节设为黑色
       2. 将祖父节点设为红色
       3. 将祖父节点设为当前节点，继续对当前节点执行操作
     - 叔叔节点是黑色，且当前节点和父节点在同一边
       1. 将父节点设为黑色
       2. 将祖父节点设为红色
       3. 以祖父节点为支点进行旋转，当前节点和父节点为左，则右旋，否则左旋
     - 叔叔节点是黑色，且当前节点和父节点不在同一边
       1. 以父节点为支点进行旋转，当前节点为右，则左旋，否则右旋
       2. 转至父红叔黑，且父子同边的情况

#### 删除

1. 查找删除元素D

2. 删除元素D，根据删除情况判断是否需要进行平衡修正：

   1. **若D无子节点**：
      1. D为红色：直接删除，不会影响路径上黑色节点个数
      2. D为黑色：直接删除，并将D原本的位置设为当前位置，进行平衡修正

   2. **D有一个子节点**：删除D，让子节点代替其位置，并将子节点设为黑色
      - 必有：D为黑色，子节点为红色，否则D到NULL节点经过的黑色节点数不等

   3. **D有两个子节点**：把后替节点值赋给该节点，然后将后替节点设为删除节点
      - 后替节点必有：只有一个子节点或没有子节点，所以又回情况1或情况2

   

   我们发现，**只有情况1.2删除元素D无子节点且D为黑色时需要复杂的平衡修正**

   - **N**：表示需要平衡的当前节点（N在递归时会变化，且可能为空，如刚删除的时候）
   - **P**：表示当前位置的父节点
   - **S**：表示当前节点的兄弟节点
   - **SL**：当前节点兄弟节点S的左孩子
   - **SR**：当前节点兄弟节点S的右孩子
   - **GP**：表示当前节点的祖父节点
   - **U**：表示当前节点的叔叔节点

   删除节点D无子节点且其为黑色时，需要进行平衡修正，修正规则如下：

   1. N 为根节点：无需任何操作

   2. N 的兄弟节点 S 为黑色：

      1. S 的子节点 SL 和 SR 全为黑色

         - 此情况下把 S 设为红色而不会和其子节点冲突，再根据父节点P决定下一步

         1. 父节点P为黑色：将S设为红色，将P设为当前节点N，向上递归处理
            - P到NULL节点路径上的黑色节点数少了1，需要对P进行平衡
         2. 父节点P为红色：将S设为红色，P设为黑色，结束
            - P到NULL节点路径上的黑色节点不变

      2. S的子节点SL和SR不全为黑色：黑红、红黑、红红”

         1. S为P的左孩子，SL为红色：
            - 以P为支点进行右旋，交换S和P的颜色，再将SL设为黑色
         2. S为P的右孩子，SR为红色：
            - 以P为支点进行左旋，交换S和P的颜色，再将SR设为黑色
         3. S为P的的左孩子，SL为黑色：
            - 以S为支点左旋，交换S与SR颜色，
            - 此时，原SR成了S，原S成了SL，S为黑色，SL为红色，转到2.2.1
         4. S为P的右孩子，SR为黑色：
            - 以S为支点右旋，交换S与SL颜色
            - 此时，原SL成了S，原S成了SR，S为黑色，SR为红色，转到2.2.2

   3. N的兄弟节点S为红色：

      1. S为左孩子：以P为支点进行右旋，交换S与P颜色，此时SR成了N新的兄弟节点
      2. S为右孩子：以P为支点进行左旋，交换S与P颜色，此时SL成了N新的兄弟节点

      - 此时N兄弟节点为黑色，转到2进行处理

   **总结：**

   1. 与二叉查找树相同，删除有两个子节点的节点，用后继结点代替删除
   2. 删除红色叶节点，无需修正平衡
   3. 删除只有一个子节点的节点，用子节点代替原节点并把子节点设为黑色
   4. 删除黑色叶节点，根据当前位置及其兄弟节点颜色进行平衡修正
      - 兄弟节点为红色，以父节点为支点，根据兄弟节点位置进行旋转，转换成兄弟节点为黑色的情况
      - 兄弟节点为黑色，根据兄弟节点子节点颜色、兄弟节点位置或父节点颜色进行处理

#### 时间复杂度

- 查找：O(logN)，由于非严格，其高度超过AVL树，所以查找性能稍弱
- 修改：O(logN) = 查找O(logN) + 更改O(1)
- 插入：O(logN) = 查找O(logN) + 插入节点O(1) + 旋转O(1)，插入时rebalance频率更低
- 删除：O(logN) = 查找O(logN) + 删除节点O(1) + 旋转O(1) ，删除性能优于AVL树

#### 优势（对比AVL）

1. 删除效率更高：通过为节点增加颜色，使用非严格平衡换取低旋转次数
   - 红黑树可以在三次旋转之内解决任何不平衡
   - AVL和红黑树插入时的平衡修正都是最多两次旋转，即旋转时间O(1)
   - 删除时，AVL最坏需要修正路径上所有节点的平衡性，即旋转时间O(logN)
   - 而红黑树删除时的平衡修正最多需要3次旋转，即旋转时间O(1)
2. 在频繁插入和删除的场景下，红黑树效率更高
   - AVL是严格平衡树，更容易引起失衡，在大量插入或删除操作时，rebalance频率更高
3. 红黑树查询性能略逊于AVL树，但插入、删除操作效率更高，综合性能更好，稳定性更好



### B树

- 平衡多路查找树
- 键值：从左到右依次增大
- 子节点数：1 <= 非叶节点的子节点数 <= 树的度M
-  每个节点的键数：ceil(M/2) - 1 <= 键数 <= M - 1
- 所有叶节点在同一层

树的度为M时，非叶节点的度大于0且小于

#### 查找

1. 依次比较目标键值与节点的键值，找到节点所在的区间，

2. 再到下一级节点进行查找，直到键值相等，找到目标

#### 插入

- 排序规则：键值大于左边所有节点键值，小于右边所有节点键值
- 节点拆分：依次插入，直到键值数目达到最大，将中间的键值放到父节点上

#### 删除

- 删除后若某节点关键字数小于ceil(M/2)-1，则需要进行节点合并
- 节点合并：优先从子节点取节点，子节点没有符合条件的再从父节点取

#### 优点

- 节点度更大，关键字更多，树高度更低，能够以更少的I/O次数实现各种操作，性能更好
- 用于数据库时，将每个节点大小设为数据页大小，能够充分利用磁盘预读特性
- 若经常访问的数据离根节点很近，检索效率比B+树高



### B+树

- B树的变种：所有数据储存在叶节点，非叶节点不保存数据，只充当数据索引
- 高度更低：非叶节点能储存更多的key，使得树的度更大，高度更低，性能更好
- 速度更稳定：每次都要在叶节点访问数据，
- 数据有序：所有叶节点按序存储，构成一个有序链表，区间查询及排序性能更好
- 全节点遍历更快：只需遍历所有叶节点而不需全表扫描



### B*树

- B+树的变种，每个节点的关键字个数范围为：ceil(2/3*M) ~ M
- 关键字转移：节点关键字满时，优先向兄弟节点转移指针，若兄弟节点也满，则节点与兄弟节点各出1/3M创建新节点
- 较B+树空间利用率更高，且存有兄弟节点指针，其转移特性使得其拆分次数更少



### Hash树

#### 特点

1. 基于质数分辨定理：n个不同的质数可以分辨他们乘积个数的连续整数
   - 任意在此范围内的整数对n个质数分别求余得到的余数序列必定不同

2. 结构：
   - 第 i 层节点的子节点个数为第i个质数大小，分别表示对第 i 个质数取余为0，...，i-1
   - 比如根节点的子节点数为2，分别为对2取余为0，1
3. 对于超长字符串，可以通过MD5等消息压缩算法得到定长整数

#### 与B+树比较

1. 优点：结构简单，查找迅速，删除时结构不变；
2. 通过取余操作直接获得某一key值对应所处的下层节点，而不用依次比较，复杂度接近O(1)
3. 数据储存没有顺序，不支持排序



### Trie树

- 字典树，Hash树的变种
- 其储存方式为：根节点到每个尾节点的路径就是一个字符串（不是叶节点，若该节点为字符串结尾，则将该节点标记为尾节点）
- 大量字符串的统计、排序和保存，如搜索引擎文本词频统计
- 利用字符串公共前缀减少无畏字符串的比较，缩短查询时间，查询效率比Hash树高



## 图

- 有穷结点与有穷边组成的数据结构
- 一个结点有复数的出度和入度
- 分为有向图和无向图
- 常见储存结构：邻接矩阵、邻接表、十字链表、邻接多重表、





# 算法



​       理解并可以分析时间和空间复杂度。

## 排序算法

各类排序算法以及复杂度分析（**快排、归并、堆**）           

二分查找和各种变种的二分查找    

​        

## 字符串类算法

双指针（滑动窗）

KMS

辅助栈

辅助优先队列



## 堆算法

前K大：小顶堆（前K）+大顶堆（K以后）



## 图算法

### BFS



### DFS



## DP动态规划



## 贪心思想

















数组、**链表、二叉树**、队列、栈的各种操作（性能，场景）            

​       

​        

​                 

​       

​               

​       